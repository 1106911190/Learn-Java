		/*
		*
		*虽然在JavaScript中单引号与双引号可以混用。
		*但java中的String极为严格
		*定义String时只能用双引号"
		*不能用单引号'
		*定义chat时使用'
		*单引号和双引号应严格区分开。
		*
		*/
		/*
		*
		*而且即使是在java中使用注释掉的中文也会有编码问题，无法正常解析。
		*无论是使用GBK还是utf-8
		*不知道是java的原因还是cmd的原因
		*因为cmd本身无法显示utf-8的中文
		*只能显示GBK的中文
		*如果想要显示utf-8的中文的话
		*输入	 	chcp 65001
		*方可显示utf-8格式编码中文
		*输入		chcp 936
		*仍然显示GBK的中文
		*
		*/
		/*
		*
		*indexOf() 
		*如果括号中是单引号
		*该方法返回给定字符第一次出现的位置
		*如果括号中是双引号
		*该方法返回给定字符串第一次出现的位置
		*
		*/
		/*
		*
		*++ 在前为先加后用，++ 在后为先用后加
		*
		*/
		/*
		*
		*处理java错误 "编码 GBK 的不可映射字符"
		*首先记事本打开java源文件
		*然后另存为，选择ANSI编码
		*覆盖
		*
		*/
		/*
		*
		*java的String是类，不是数据类型
		*String对象表示的字符串不能改变
		*若要一个可以改变的字符串
		*应该使用StringBuffer
		*
		*/
		/*
		*
		*for循环只能循环数组
		*不能循环String类型
		*数组是基本数据类型
		*但是String是一个类
		*
		*/
		/*
		*
		*String是一个类
		*所以不能直接用==来比较是否相同
		*虽然不会报错，但是有问题
		*这样比较的是两个对象的内存地址
		*应该用StringA.equals(StringB)来进行比较
		*对象之间的比较用equals(ObjectA,ObjectB)
		*不能用后一种方法来比较字符串
		*而具体的比较两个对象
		*一般需要自己重写equals方法
		*
		*/
		/*
		*
		*创建泛型数组错误
		*因为数组可以直接创建基本数据类型
		*如 char[] items = new char[10]
		*但是String不能这样创建
		*或者是泛型也不可以
		*需要先创建一个对象
		*再强制类型转换为相应的类型
		*如String[] data = (String[]) new Object[10]
		*如E[] data = (E[]) new Object[10]
		*
		*/
		/*
		*
		*注: work2.java使用了未经检查或不安全的操作。
		*注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。
		*不影响编译，只是一个警告
		*可以直接运行
		*
		*/
		/*
		*
		*在Java中真是true 假是false 
		*在Python中真是True 假是False
		*
		*/
		/*
		*
		*多态的两种实现
		*运行时多态 一个父类方法，不同子类不同实现
		*编译时多态 在一个类中，相同的方法名，多个不同参数的方法实现
		*
		*/
		/*
		*
		*Javadoc 自动生成HTML文件的文档
		*用/**  */包含起来的是文档
		*用/*   */包含起来的是注释
		*
		*/
		/*
		*
		*基本数据类型可以直接声明就使用
		*但是引用数据类型就需要声明再实例化再使用
		*比如说各种类
		*但是String也是一个类
		*却可以直接使用
		*还有各种List Map等等
		*可是数组竟然也是引用数据类型
		*
		*/
		/*
		*
		*Java中没有全局变量
		*只有局部变量 类成员变量 方法参数 和异常处理参数
		*类成员变量会自动初始化
		*方法参数不会自动初始化
		*而且 最重要的一点
		*只有类成员变量才有什么public static protected
		*在局部变量中没有这些修饰符
		*也不能用static
		*但是！！！可以用final
		*
		*main函数 main函数 main也是一个函数吖！
		*在main函数中定义的变量 是局部变量
		*也需要手动的初始化
		*在main函数中定义的变量没有初始化也会报错
		*
		*在main函数中的变量不会自动初始化，因为其是局部变量
		*但是可以在public之内 main之外定义变量
		*那里的变量是类成员变量是会自动初始化的
		*
		*/
		/*
		*
		*神奇的操作符
		*在Java中不同的数据类型混合运算 低级运算符会自动转化为高级运算符
		*由低到高 byte short char int long float double
		*分别是   8    16	 32   32  64   32    64 位
		*但是 如果两个操作符全是byte或者short 结果也会是int （好TMD贴心吖）
		*取摸运算符可以为浮点数 5.4%5 = 0.4
		*这个表中没有boolean 因为无法数据转化 任何数据类型都不能转化为boolean 同样boolean也不能转换为任何数据类型
		*无论是自动还是强制
		*boolean长度只占1位 声明之后默认初始化为false
		*
		*/
		/*
		*
		* +x 将byte 或 short 或 char型数据提升为 int型 ~x 也有类似的效果
		* -x 取反 也能做数据类型提升
		* ++x 先加再用
		* x++ 先用再加
		* --x 先减再用
		* x-- 先用再减		
		* 
		*/
		/*
		*
		*在Java中基本数据类型和引用数据类型都可以用== 或者！= 老比较是否相等
		*但是 对于引用数据类型 它们比较的是地址还是值吖？
		*
		*比较的是地址
		*跟Python一样
		*也是跟C语言的结构体一样
		*正常情况下是没有办法直接比较值的
		*它就是一个指针
		*
		*如果想比较两个引用型数据，如String
		*请使用equals
		*
		*/
		/*
		*
		*&& || ! 在判断时表示 与 或 非
		*在C语言中是自动表示短路的 
		*即 如果与操作的左半部分为假 即不再进行右半部分求值 直接判定为假
		*可是在Java中 && || 是短路与 短路或与C语言一致
		*还有& | 不短路与 不短路或
		*可是& | 还表示按位与 和按位或 
		*还有^ 即是逻辑运算符异或 又是位运算符 按位异或
		*这样没法判断了吖！
		*
		*根据返回值类型
		*返回为Boolean即为逻辑运算符
		*返回为整数类型即为位运算符
		*
		*/
		/*
		*
		* x>>y x按位右移y位 即x除以2的y次方
		* x<<y x按位左移y位 即x乘以2的y次方 最高位取原最高位
		* x>>>y x按位右移y位 最高位取0
		* x<<<y 没有
		*
		*/
		/*
		*
		*赋值运算符= 以左为尊
		*如果左边的操作数的级别高
		*则右边的操作数自动向高转化
		*但是如果右边的操作数的级别高
		*因为操作数无法自动的由高向低转化
		*所以需要强制类型转化
		*
		*/
		/*
		*
		*虽然在Python中 while 1 要比while True要快
		*但是在Java中 只能写while(true) 不能写while(1)
		*或者是其他的数据类型
		*因为其他的数据类型无法自动的转化为boolean
		*强制数据类型转换也不行
		*只能这样写while(1!=0)
		*
		*/
		/*
		*
		*switch中的表达式和case只能是整数类型
		*整数类型就只能用byte short char 和 int
		*因为只有它们能够自动的转换为int型
		*如果想要比较double或者float 还是用if else吧
		*class 或者是 String 就更不要想了
		*
		*感觉好像跟C语言不一样，但是一来它用的少，二来用到的时候好像也就比较char型和int型
		*
		*/
		/*
		*
		*Java中的数组不是基本数据类型
		*是一个类，引用数据类型。
		*需要先声明，再实例化，再使用。
		*但是在main函数中的数组，会自动的先初始化为0。
		*并不像其他的基本数据类型
		*但是String却不会先初始化
		*真是神奇，String是引用数据类型
		*但是又像基本数据类型
		*
		*但是神奇的数组还不止如此
		*它还可以在声明的时候初始化
		*就可以不用实例化了
		*然而就算是这样
		*它还是个引用 == 或者equals都不相等
		*不是和String一样作为基本数据类型
		*
		*/
		/*
		*
		*因为局部变量不会自动初始化
		*自动初始化的只有类成员变量
		*所以还是不要想着自动初始化 
		*自己手动初始化要保险的很多
		*
		*像for循环中的int i 或者是在前面int 的i 都需要先设为0
		*如果是在循环中的int i 循环结束即不可用
		*再下次循环时需要再次int i
		*
		*/
		/*
		*
		*在数组或者是类中，直接进行两个对象的赋值操作= 只是将引用赋值过去了
		*也就是指针的操作，跟C语言一模一样
		*但是如果是仅声明而未实例化的类还好理解
		*可是已经声明并实例化的类 为什么还是指针赋值过去了？
		*就像在C语言中对一个指针分配了内存空间 就没有办法在对其赋值指针了 会报错
 		*难道这就是Python中的深拷贝
 		*就像Java中对数值的赋值需要一个专门的函数
		*System.arraycopy(Object source,int srcindex,Object destitation,int destindex,int length)
		*
		*/
		/*
		*
		*Java中的关键字是大小写敏感的
		*好像哪里的关键字大小写不敏感
		*记不太清了
		*必须以_或者是$或者是字母开头
		*不能以数字开头
		*
		*/
		/*
		*
		*将整形按十六进制查看
		*Integer.toHexString()
		*其实就算是char型也可以
		*因为有自动类型转换 向上转型
		*
		*/
		/*
		*
		*System.out.println(0.0 == -0.0); //true
		*System.out.println(0.0 > -0.0); //false
		*System.out.println(1.0 < Double.NaN); //false
		*System.out.println(1.0 > Double.NaN); //false
		*System.out.println(1.0 == Double.NaN); //false
		*System.out.println(1.0 != Double.NaN); //true
		*System.out.println(0.0 / 0.0); //NaN
		*System.out.println(1.0 / 0.0); //Infinity
		*System.out.println(1.0 / -0.0); //-Infinity
		*
		*
		*注意以上操作都是基于浮点数的
		*整数除以0 编译不报错
		*但是运行时会出异常
		*可以浮点数除以0
		*也可以整数除以0.0
		*
		*/
		/*
		*
		*只要是在Windows上运行
		*与cmd和中文有关的
		*最好是用GBK 真是坑爹
		*
		*/
		/*
		*
		*在任何地方的比较大小
		*都尽量避免使用浮点数
		*会有浮点陷阱
		*不精确会有很严重的后果
		*
		*/
		/*
		*
		*在C语言或者还是Java中
		*定义a[10]的数组就是10位的数组
		*表示长度，最大到a[9]
		*
		*
		*/
		/*
		*
		*方法传递参数如果是引用数据类型是引用
		*也就是说在方法中改变参数值，在原变量会改变
		*当然如果是基本数据类型就不是引用
		*同样的String不是引用
		*数组是引用
		*
		*
		*/
		/*
		*
		*在Java中的main函数中
		*无法调用在public class里面 main函数外面的非静态方法
		*即使它是public的方法
		*只能调用外面的静态方法
		*不过还有一个办法
		*就是先初始化一个public class
		*然后用这个对象去调用public class里面 main函数外面的方法
		*这个时候就只能调用非静态方法
		*而且不管是静态方法还是非静态方法都可以
		*
		*/
		/*
		*
		*原来所谓的一个java文件中只能有一个public类
		*因为类的访问权限就只有两种 public和default(默认，即什么都没有)
		*在一个public类中还只能有一个main函数
		*只有成员变量和方法才有public protected default private等访问权限控制
		*
		*/
		/*
		*
		*普通的类的修饰词只有两种
		*public 和 default
		*但是内部类 可以用public protected default private
		*和static 如果用static即相当于外部类
		*
		*/
		/*
		*
		*静态变量可以通过类来直接访问
		*也可以通过实例化对象来访问
		*并没有关系
		*
		*/
		/*
		*
		*普通的类不仅只有public 和 default两种修饰词 
		*还可以有final
		*还可以是abstract
		*static只能内部类才能用
		*
		*/
		/*
		*
		*类在被实例化时
		*先初始化成员变量
		*再执行构造函数
		*
		*/
		/*
		*
		*一个类中的静态变量在这个类第一次被实例化时被初始化
		*当这个类再次被实例化时
		*静态变量不再执行
		*但是静态方法在类被实例化的时候不动
		*实际上除了构造方法
		*所有方法都不动
		*
		*/
		/*
		*
		*如果想要在初始化的时候就执行某段代码
		*可以在构造函数里
		*或者在成员变量里 调用其他类的构造函数
		*或是用static{}包围起来
		*
		*/
		/*
		*
		*final的类不能被继承
		*final的方法不能被重写
		*final的变量不能被修改
		*但是如果这个变量是引用型变量的话
		*引用不被修改
		*但是引用的值可以被修改
		*
		*/
		/*
		*
		*赋值语句必须在方法体中
		*比如说某个String或者是数组或者是什么变量
		*刚声明 还没来的及初始化
		*那么初始化必须在方法里
		*不能在类里方法外
		*
		*/
		/*
		*
		*构造方法，如果在父类或者爷类中有无参的构造方法，则会依次从上往下全部执行。
		*因为在每一个构造器中都有一个隐藏的无参的super()构造方法
		*所以如果你的父类构造方法是含参的话，就必须要有手动的添加super(参数)来调用父类的构造方法
		*
		*可是如果有时候我们希望重写父类的构造的方法怎么办，希望父类的构造方法不要执行
		*没有办法，子类不能覆盖或重写或继承父类构造方法
		*覆盖或重写是其他方法的，不包括构造方法
		*继承是子类与父类的，不包括构造方法
		*这几个名词都用错了
		*它只是在构造子类时一定会构造父类
		*
		*可是我们还是希望在构造子类的时候值调用子类的构造方法，不调用父类的构造方法怎么办
		*那就是多态了		//这不是多态
		*因为父类的构造方法是一定会调用的，所以我们可以写一个空的构造方法就可以了
		*但是，在子类中无法对父类的构造方法操作
		*所以就在父类中直接创建两个构造方法
		*一个含参的，一个不含参的，不含参的用来子类继承时不受任何影响
		*如果想要调用含参的构造方法也很简单，用super(参数)就可以了
		*
		*所以现在就有了四种情况（不含参的构造方法同无显式构造方法）
		*父类含参，子类不含参
		*父类含参，子类含参
		*父类不含参，子类含参
		*父类不含参，子类不含参
		*又根据是否需要调用父类的构造方法分为调用父类的构造方法，不调用父类的构造方法
		*
		*1. 父类含参，子类不含参
		*不调用父类的构造方法
		*如果真的父类只有一个含参的构造方法，子类只有一个不含参的构造方法是不可能的，会报错
		*所以如果希望不调用父类的构造方法，也就是需要一个无参的内容为空父类的构造方法
		*然后在无参的子类构造方法中就会自动调用super()来调用父类的无参构造方法		
		*调用父类的构造方法
		*那么只需要在上面的子类里再加一个含参的构造方法就可以了，同时在这个构造方法里需要显式的调用super(参数)
		*但是这样就与我们一开始的假设子类不含参相悖了 
		*
		*2. 父类含参，子类含参
		*不调用父类的构造方法
		*那么同样的在父类中构造一个含参的构造方法，一个不含参的内容为空构造方法
		*那么在子类含参的构造方法中因为会自动的调用super()所以会调用父类的不含参的构造方法
		*调用父类的构造方法
		*那么父类就可以只有含参的构造方法就可以了
		*在子类构造方法中下显式的调用super(参数)来调用父类的构造方法
		*
		*3. 父类不含参，子类含参
		*不调用父类的构造方法
		*如果父类的构造方法内容不为空的话，想要不调用这个构造方法是不可能的
		*无论子类构造方法是怎样，一定会调用super()
		*所以父类的不含参的构造方法一定会调用
		*想要不调用的话，就算没有用到参数，也还是给它来一个空的参数吧
		*调用父类的构造方法
		*因为在子类构造时会自动的调用super()
		*所以肯定调用父类的构造方法
		*
		*4. 父类不含参，子类不含参
		*不调用父类的构造方法
		*同父类不含参子类含参
		*为父类不含参的构造方法增加一个参数
		*然后再写一个不含参的内容空的构造方法
		*这样在子类的构造方法就是调用父类的不含参的构造方法了
		*调用父类的构造方法
		*因为子类在构造失肯定会调用父类不含参的构造方法
		*所以自动的就会调用
		*
		*/
		/*
		*
		*因为构造方法比较特殊，不会被重写或隐藏，这些是普通方法在子类中会被做的事
		*所以接下来我们看一下子类的方法会被怎样的
		*子类覆盖父类的普通方法，必须有同样的参数和返回值，返回类也可以是父类返回类的子类
		*子类覆盖父类的普通方法，可以修改作用域修饰符，但只能把方法的作用域放大而不能把作用域缩小
		*子类覆盖父类的成员变量，父类方法用的是父类的成员变量，子类方法用的是子类的成员变量
		*
		*那么方法重写与构造函数在一起会发生什么呢？
		*在构造方法中调用普通方法，而如果这个普通方法被子类重写
		*那么在父类的构造方法就是调用子类的重写之后的方法
		*
		*
		*/

